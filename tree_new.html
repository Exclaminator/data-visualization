<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Trees</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" media="screen" href="main.css" />
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <!-- <script src="./d3.v4.min.js"></script> -->
        <script src="./Collatz.js"></script>
        

    </head>
    <body>
        <svg id="visje"></svg>
        <svg id="blokje"></svg>
    </body>

    <script>
        console.log(Date.now());

        const maxDepthRelative = 15;

        const diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);
        const margin = ({top: 10, right: 120, bottom: 10, left: 40});

        const height = 500;
        const width = 1500;

        const dy = 30;
        const dx = 10;

        const tree = d3.tree().nodeSize([dx, dy]);

        function makeHierarchy(collatzNodeAsRoot) {
            console.dir(collatzNodeAsRoot);
            let root = d3.hierarchy(collatzNodeAsRoot, d => {
                if (d.depth() < maxDepthRelative + collatzNodeAsRoot.depth()) {
                    return d.children();
                }
                else {
                    return null;
                }
            });

            root.x0 = dy / 2;
            root.y0 = 0;
            root.descendants().forEach((d, i) => {
                d.id = d.data.value();
                // d._children = d.children;
                // if (d.depth >= maxDepth) d.children = null;
            });

            return root;
        }

        let rootStack = [];

        let conjecture = new CollatzConjectureFast();
        let rootNodeCollatz = new CollatzNumberSimple(conjecture, 1);
        
        let root = makeHierarchy(rootNodeCollatz);

        const svg = d3.select("#visje")
            .attr("width", width)
            .attr("height", dx)
            .attr("viewBox", [-margin.left, -margin.top, width, dx])
            .style("font", "10px sans-serif")
            .style("user-select", "none");

        const gLink = svg.append("g")
            .attr("fill", "none")
            .attr("stroke", "#555")
            .attr("stroke-opacity", 0.4)
            .attr("stroke-width", 1.5);

        const gNode = svg.append("g")
            .attr("cursor", "pointer");

        function update(source) {
            const duration = d3.event && d3.event.altKey ? 2500 : 250;
            const nodes = root.descendants().reverse();
            const links = root.links();

            // Compute the new tree layout.
            tree(root);

            let left = root;
            let right = root;
            root.eachBefore(node => {
                if (node.x < left.x) left = node;
                if (node.x > right.x) right = node;
            });

            const height = right.x - left.x + margin.top + margin.bottom;

            const transition = svg.transition()
                .duration(duration)
                .attr("height", height)
                .attr("viewBox", [-margin.left, left.x - margin.top, width, height])
                .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

            // Update the nodes…
            const node = gNode.selectAll("g")
                .data(nodes, d => d.id);

            // Enter any new nodes at the parent's previous position.
            const nodeEnter = node.enter().append("g")
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0)
                .on("click", d => {
                    console.log(d);
                    console.log(root);
                    if (d.id === root.id) {
                        root = rootStack.pop();
                    }
                    else {
                        rootStack.push(root);
                        root = d;
                    }
                    root = makeHierarchy(root.data);
                    update(root);
                });

            nodeEnter.append("circle")
                .attr("r", 4)
                .attr("fill", d => d._children ? "#555" : "#999");

            nodeEnter.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d._children ? -6 : 6)
                .attr("text-anchor", d => d._children ? "end" : "start")
                .text(d => d.data.value())
            .clone(true).lower()
                .attr("stroke-linejoin", "round")
                .attr("stroke-width", 3)
                .attr("stroke", "white");

            // Transition nodes to their new position.
            const nodeUpdate = node.merge(nodeEnter).transition(transition)
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .attr("fill-opacity", 1)
                .attr("stroke-opacity", 1);

            // Transition exiting nodes to the parent's new position.
            const nodeExit = node.exit().transition(transition).remove()
                .attr("transform", d => `translate(${source.y},${source.x})`)
                .attr("fill-opacity", 0)
                .attr("stroke-opacity", 0);

            // Update the links…
            const link = gLink.selectAll("path")
                .data(links, d => d.target.id);

            // Enter any new links at the parent's previous position.
            const linkEnter = link.enter().append("path")
                .attr("d", d => {
                    const o = {x: source.x0, y: source.y0};
                    return diagonal({source: o, target: o});
                });

            // Transition links to their new position.
            link.merge(linkEnter).transition(transition)
                .attr("d", diagonal);

            // Transition exiting nodes to the parent's new position.
            link.exit().transition(transition).remove()
                .attr("d", d => {
                    const o = {x: source.x, y: source.y};
                    return diagonal({source: o, target: o});
                });

            // Stash the old positions for transition.
            root.eachBefore(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
            
            // barChart(root);
        }

        update(root);

        svg.node();
        
        ///////
        // Bar chart
        ///////

        function barChart(root) {
            const squareSize = 10;
            let collatzNumbersToPlot = [];

            let rootValue = mapping.get(Number(root.data.name));
            collatzNumbersToPlot.push(rootValue);

            for (let i = 1; i < 50; i++) {
                collatzNumbersToPlot.push(addCollatz(rootValue.value + i))
            }

            d3.select("#blokje").remove();
            var svgContainer = d3.select("body").append("svg")
                .attr("id", "blokje")
                .attr("width", width)
                .attr("height", height);

            collatzNumbersToPlot.forEach(function(d, i) {
                let dp = d.value;
                let j = 0;
                d.traverseDown(function(d) {
                    svgContainer.append("rect")
                        .attr("x", i*squareSize)
                        .attr("y", height - (j*squareSize))
                        .attr("width", squareSize)
                        .attr("height", squareSize)
                        .attr("fill", (d - dp) > 0 ? "green" : "red");
                    dp = d.value;
                    j++;
                });
            });
        }
    </script>

</html>